### Компоненты MVC

Лучший способ рассмотреть архитектуру MVC - это рассмотреть каждый компонент в отдельности. Мы
начнем с Модели и представления (Model, View), потому что, в таком порядке они идут в аббревиатуре, и мы закончим 
Контроллером (Controller), который вполне подходит, так как связывает все вместе, как вы увидите.

#### Модель (Model)

Модель в MVC - это часть вашего приложения, которая представляет ваши данные. Конкретная модель
это класс, который представляет данные. Рассмотрим этот пользовательский класс:

```php
class User extends AbstractModel {
  public $id;
  public $alias;
  public $fullName;
  public $email;
}
```

Эта модель представляет пользователя в нашей системе. Обычно слой модели имеет несколько методов для создания и 
фильтрации данных в модели, а также их сохранение в реальном хранилище данных. Подробнее об этом мы поговорим в разделе
"Независимость базы данных".

Как разработчик, мы можем манипулировать этой моделью как любым PHP классом:

```php
$user = new User();

$user->alias = 'billybob';
$user->fullName = ‘William Bob';
$user->email = 'william.bob@bobcorp.com';
```

Сравните это с традиционным использованием PDO или прямыми методами mysql_* или mysqli_*:
здесь мы используем полностью зарезервированные объекты, которые представляют наши данные, а не запрашиваем их и 
работаем с массивами данных. На самом деле, мы имеем представления данных с помощью этого метода.

#### Представление (View)

Вид в MVC - это то, что показано пользователю. В мире PHP представление в основном состоит из HTML, CSS и JavaScript, 
которые управляют пользовательским интерфейсом. Вид также отвечает за взаимодействие пользователя с приложением 
с помощью ссылок, кнопок, JavaScript и т.д. Эти действия могут быть полностью обработаны на уровне представления,
или они могут делать дополнительные запросы к веб-серверу для загрузки других данных и представлений.

Вид также отвечает за получение моделей и отображение их в пользовательской части приложения. Например, для нашей модели 
User у нас может быть страница, которая итерирует через коллекцию пользователей и отображает их в сетке:

```php
<table>
    <thead>
      <tr>
        <th>ID</th>
        <th>Full Name</th>
        <th>Email</th>
        <th>&nbsp;</th>
      </tr>
    </thead>
  <tbody>
    <?php foreach ($this->users as $user): ?>
    <tr>
        <td><?= $user->id ?></td>
        <td><?= $user->fullName ?></td>
        <td><?= $user->email ?></td>
        <td><a href="/users/edit/<?= $user->id ?>">edit</a></td>
    </tr>
    <?php endforeach; ?>
  </tbody>
</table>
```

Наш слой представления очень удобен: он предназначен для отображения данных пользователю. Он не обрабатывает данные 
кроме как перебора данных в цикле и условий. Он ничего не запрашивает напрямую, просто манипулирует данными, которые ему передаются.
Но как именно представление получает свои данные?

#### Контроллер (Controller)

Контроллер отвечает за интерпретацию запроса пользователя и ответ на него. Он может загрузить определенные модели, 
относящиеся к запросу, и передать их в представление, или он может принять данные из представления 
(через что-то вроде HTTP POST запроса) и перевести их в модель и сохранить в хранилище данных.

Контроллеры бывают разных форм, но одна из наиболее распространенных форм - это контроллер действий. Эти контроллеры 
представляют собой классы, которые содержат один или несколько методов, каждый из которых представляет собой определенный запрос.

Если мы продолжим пример с пользователем, у нас может быть UsersController, который отвечает за обработку запросов, имеющих отношение к пользователям:

```php
class UserController extends AbstractController {
    public function indexAction() {}
    public function viewAction() {}
    public function updateAction() {}
}
```

В этом примере три метода (action).

    1. indexAction отвечает за вывод всех пользователей
    2. viewAction отвечает за вывод данных по одному пользователю
    3. updateAction отвечает за обновление данных пользователя

По конкретному запросу, скажем, запросу клиента на просмотр, будет вызвано соответствующее действие, которое обработает 
запрос и подготовит требуемое представление. Это может выглядеть примерно так:

```php 
public function viewAction() {
    $id = $this->params('id');
    $user = $this->repository->getByid($id);
    $view = new View();
    $view->setFile('users/view.phtml');
    $view->setData(['customer' => $user]);
    return $view;
}
```

Это действие псевдоконтроллера в данном примере кода извлекает переданный ID из какого-то механизма, а затем использует 
хранимый в хранилище UserRepository для извлечения этого пользователя. Наконец, оно создает новое представление, 
устанавливает файл представления для рендеринга и передаёт данные с помощью функции setData().

Здесь мы видим, что контроллер занимается только ответами на запросы. Он использует уровень модели для получения данных, 
а затем передает их на уровень представления для обработки и отображения.

#### Маршрутизатор (Routing)

Все это начинает приобретать гораздо больший смысл, если задуматься о том, как работает маршрутизация в MVC-приложениях, 
основанных на веб-технологиях. В наши дни мы склоняемся к использованию чистых URL, где наш URI выглядит именно так:

/users/view/1

Или, если вы описываете RESTful URI: 

/users/1

По той ссылке мы сможем увидеть viewAction обратившись к контроллеру UserController.
Традиционно при маршрутизации чистых URL, первая часть URI, /users указывает на контроллер, UsersController в 
нашем примере, в то время как часть, /view, указывает на Action, который, конечно же, является методом viewAction.

Однако это не всегда так.Большинство фреймворков позволяют маршрутизации быть чем угодно так, что любой URI может 
сопоставить его с любым контроллером или действием. 

Некоторые фреймворки не требую никаких настроек и обращение к методам контроллеров очевидны.
Они просто сопоставляют URI с соответствующим контроллером и действием. Большинство современных фреймворков требуют, 
чтобы вы установили некую таблицу маршрутизации, которая указывает, какие URI отображаются на какие части кода.

#### MVC Недостаточно хорош

Архитектура MVC - это отличное начало для создания надежного и адаптируемого программного обеспечения, но этого не всегда достаточно.
Имея всего три слоя, в которых можно организовать весь код, разработчик, как правило, описывает слишком много деталей в одном из слоев.
Довольно самонадеянно думать, что всё должно поместиться в три корзины. Либо это модель, либо вид, либо контроллер.
Представление обычно избавляют от логики, так как его роль довольно хорошо определена, поэтому либо контроллеры 
переполняются бизнес-логикой, или модель поглощает все это. Обычно используют систему "жирная модель, тонкий контроллер".

#### Жирная модель (Obese Models)